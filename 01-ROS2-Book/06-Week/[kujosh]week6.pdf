21장 ROS 2의 시간

 21.1 시계(Clock)와 시간(Time)
 - 다수의 센서를 사용하는 로봇은 시간에 따른 각 센서 값의 변화량과 그 센서들 간의 시간 동기화가 매우 중요
 - ROS 2는 여러 노드들이 서로 통신하며 다양한 정보들을 주고받기 때문에 해당 정보들이 퍼블리시된 정확한 시간이 필수적
 $ ros2 run time_rclcpp_example time_example --ros-args -p use_sim_time:=false
 - 위 명령어를 실행하여 ROS 2의 시계와 그 시간을 확인할 수 있다.

 21.2 시간 추상화 (Time Avstactions)
 - 타임머신처럼 동작하는 시계도 사용 가능한데, 과거 어느 시점으로 시간을 돌려줄 수 있고 시간을 더 빠르게 흘러가게 해줄 수도 있으며 시간을 멈출 수도 있다.
 - 과거에 기록한 데이터를 다룰 때(ros2bag)나 로봇 시뮬레이션(gazebo, ignition)에서 사용할 수 있다.
 - 총 세 가지의 시간을 제공하고 있다.
  21.2.1 System Time
   - server pc와 remote pc 간의 데이터 통신을 원활히 하기 위한 시간 동기화
  21.2.2 ROS Time
   - 보통 시뮬레이션 환경에서 시간을 조절하기 위해 많이 사용된다.
  21.2.3 Steady Time
   - Hardware timeouts를 사용한 시간
   - 무조건 단조증가(monotonic)한다는 특성을 가진다.

 21.3 Time API
  - ROS 2에서 제공하는 시간과 관련된 API는 크게 time, duration, rate가 있다. 
  21.3.1 Time
   - Time 클래스는 시간을 다룰 수 있는 오퍼레이터를 제공하며 그 결과를 second(double형) 혹은 nanoseconds(64비트형)을 가지며, nanoseconds가 더 정확한 시간을 반환한다.
   - ROS 2 노드에서는 now 멤버 함수를 통해 노드 시간을 확인할 수 있다.
  21.3.2 Duration
   - Duration 클래스는 순간의 시간이 아닌 기간(3시간 후, 1시간 전)을 다룰 수 있는 오퍼레이터를 제공하며 그 결과를 seconds 혹은 nanoseconds 단위로 반환해준다.
   - Time과의 연산이 가능하여 보다 직관적으로 시간을 다룰 수 있다.
  21.3.3 Rate
   - Rate 클래스는 반복문에서 특정 주기를 유지시켜 주는 API를 제공한다.

22장 ROS 2의 파일 시스템

 22.1 파일 시스템
 - ROS 패키지 및 소스코드를 검색하거나 메시지 파일, 실행 파일, 파라미터 성정 및 환경설정 파일 등을 이용할 때 사용자에게 일관된 경험을 제공하기 위해서 동일한 구조를 가지고 있다.

 22.2 패키지와 메타패키지
 - ROS 2에서 소프트웨어 구성을 위한 기본 단위는 패키지로써 ROS의 응용 프로그램은 패키지 단위로 개발되고 관리된다. 
 - 공통된 목적을 지닌 패키지들을 모아둔 패키지의 집합 단위인 메타패키지로 관리된다.

 22.3 바이너리 설치와 소스코드 설치
 - 별도의 빌드과정 없이 바로 실행하는 바이너리 형태
 - 해당 패키지의 소스코드를 직접 내려받은 후 사용자가 빌드해 사용하는 방법 (해당 패키지를 수정해 사용할 경우나 소스코드 내용 확인이 필요할 경우)

23장 ROS 2의 빌드 시스템과 빌드 툴

 23.1 빌드 시스템과 빌드 툴
  - 빌드 시스템은 단일 패키지를 대상으로 하며, 빌드 툴은 시스템 전체를 대상으로 한다.

 23.2 빌드 시스템 (Build system)
  - ROS 1에서는 CMake, ROS 2에서는 ament를 사용한다.
  - CMake를 이용한느 이유는 ROS 패키지를 멀티 플랫폼에서 빌드할 수 있게 하기 위함이다.
  - ament는 크게 두 가지인데 ament_cmake는 ROS 1 catkin 업그레이드 버전으로 devel 공간을 사용하지 않는다는 것이다.
  - 그리고 ROS 1의 catkin이 CMake만을 지원했던 반면, ament는 ament_python으로 파이썬 패키지 관리도 지원한다.

 23.3 빌드 툴 (Build tools)
  - ROS 2 패키지를 작성, 테스트, 빌드 등 ROS 2 기반의 프로그램을 개발할 때 빼놓을 수 없는 툴인 colcon을 이용한다.
  - 작업 흐름을 향상시키는 CLI 타입의 명령어 도구로 터미널 창에서 수행하게 되며 다양한 옵션과 함께 사용할 수 있다.

 23.4 패키지 생성
  - 첫 번째 방법: 직접 패키지 폴더를 만들고 그 안에 파일 시스템에 필수적인 package.xml이나 CMakeLists.txt 또는 setup.py 등을 포함시켜 주고 소스코드를 작성
  - 두 번째 방법: ros2cli 명령어를 이용하는 것
  - $ ros2 pkg create [패키지 이름] --build-type [빌드 타입] --dependencies [의존하는 패키지1] [의존한느 패키지n]
  - [빌드 타입]: ament_cmake or ament_python (참고로 GUI 프로그램을 작성해야 한다면 파이썬을 사용한다해도 rqt plugin 계열을 써야 하기에 ament_cmake를 입력)

 23.5 패키지 빌드
  - 전체 패키지 빌드할 때
      $ cd ~robot_ws && colcon build --symlink-install 
  - 해당 패키지만 빌드할 때
      $ cd ~robot_ws && colcon build --symlink-install --packages-select [패키지 이름]
  - 해당 패키지의 의존성 패키지들까지 함께 빌드할 떄
      $ cd ~robot_ws && colcon build --symlink-install --packages-up-to [패키지 이름]

 23.6 빌드 시스템에 필요한 부가 기능
  23.6.1 vcstool (버전 컨트롤 시스템 툴)
   - 여러 리포지터리 작업ㅇ르 보다 쉽게 관리할 수 있도록 설계된 툴
  23.6.2 rosdep (의존성 관리 툴)
   - 패키지를 설치할 때 해당 패키지들의 의존성을 살펴보고 필요한 패키지들을 설치하거나 특정 패키지는 의존성 문제를 무시해준다.
  23.6.3 bloom (바이너리 패키지 관리 툴)
   - 바이너리 패키지 배포 및 관리를 위한 툴

24장 ROS 2의 패키지 파일

 24.1 패키지 파일

 24.2 패키지 설정 파일 (package.xml)
  - 패키지 이름, 저작자, 라이선스, 의존성 패키지 등의 패키지 정보를 XML 형식으로 기술해준다.
  - 모든 ROS 패키지의 필수 파일로 각 패키지당 무조건 1개의 패키지 설정 파일을 포함하고 있다.

 24.3 빌드 설정 파일 (CMakeLists.txt)
  - 위에서 말한 바와 같이 ROS에서 CMake를 이용하는 이유는 ROS 패키지를 멀티 플랫폼에서 빌드할 수 있게 하기 위함
  - C++을 사용해 만들어진 패키지는 CMakeLists.txt 파일이 존재하는데, 파이썬을 사용해 만들어진 패키지는 존재하지 않는다.

 24.4 파이썬 패키지 설정 파일 (setup.py)
  - 파이썬 패키지에서만 사용하는 배포를 위한 설정 파일로 C++ 패키지의 CMakeListx.txt와 package.xml 기능을 한다.

 24.5 파이썬 패키지 환경설정 파일 (setup.cfg)
  - setup.py파일의 setup 함수에서 설정하지 못하는 기타 옵션을 setup.cfg을 사용하여 정의할 수 있다.
  - ROS 2 파이썬 패키지에서는 이 파일에 [develop]와 [install] 옵션을 설정하여 스크립트의 저장 위치를 설정한다.

 24.6 RQt 플러그인 설정 파일 (plugin.xml)

 24.7 패키지 변경로그 파일 (CHANGELOG.rst)
  - 패키지의 업데이트 내역을 기술하는 파일
  - 개발된 패키지를 바이너리 패키지로 공개하는 절차를 수행한다면 이 파일을 필수로 포함시켜 사용자들에게 변경 사항을 버전별로 공지할 수 있다.

 24.8 라이선스 파일 (LICENSE)
  - 패키지의 코드에 사용된 라이선스를 기술하는 파일 
  
 24.9 패키지 설명 파일 (README.md)
  - 패키지의 부가 설명을 기술하는 파일